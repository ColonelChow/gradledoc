<html>

<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Overview - Gradle User Guide Version 3.2</title>
    <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="../base.css">
    <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="../docs.css">
    <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="../userguide.css">
    <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
    <link rel="home" href="../userguide.html" title="Gradle User Guide Version 3.2">
    <link rel="up" href="../pt01.html" title="Part&nbsp;I.&nbsp;About Gradle">
    <link rel="prev" href="../ch1/introduction.html" title="Introduction - Gradle User Guide Version 3.2">
    <link rel="下一页" href="../pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">
</head>

<body>
    <div class="navheader">
        <div>
            <div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="../ch1/introduction.html" title="Introduction - Gradle User Guide Version 3.2">上一页</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../userguide.html" title="Gradle User Guide Version 3.2">目录</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">下一页</a></div>
        </div>
    </div>
    <div class="chapter">
        <div class="titlepage">
            <div>
                <div>
                    <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="overview"></a>Chapter&nbsp;2.&nbsp;Overview</h1></div>
            </div>
        </div>
        <div class="toc">
            <p><b>章节目录 - Table of Content</b></p>
            <dl>
                <dt><span class="section"><a href="overview.html#sec:special_feature_of_gradle">2.1. 特性 - Features</a></span></dt>
                <dt><span class="section"><a href="overview.html#sec:why_groovy">2.2. 为何采用 Groovy - Why Groovy?</a></span></dt>
            </dl>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:special_feature_of_gradle" class="section-anchor" href="#sec:special_feature_of_gradle"></a>2.1. 特性 - Features</h2></div>
                </div>
            </div>
            <p>下面罗列了一些Gradle的特性。</p>
            <p>Here is a list of some of Gradle's features.
            </p>
            <div class="variablelist">
                <dl>
                    <dt><span class="term">声明式构建和契约式构建<br>Declarative builds and build-by-convention</span></dt>
                    <dd>
                    	<p>Gradle的核心是基于Groovy的DSL(领域特定语言)。Gradle通过提供声明式的语言元素来将声明式构建提高到一个新的水平，您可以根据自己的喜好组装。 这些元素还为Java，Groovy，OSGi，Web和Scala项目提供按惯例支持。 甚至，这种声明式的语言是可扩展的。 添加您自己的新语言元素或增强现有语言元素，从而提供简洁，可维护和易理解的构建。</p>
                        <p>At the heart of Gradle lies a rich extensible Domain Specific Language (DSL) based on Groovy. Gradle pushes declarative builds to the next level by providing declarative language elements that you can assemble as you like. Those elements also provide build-by-convention support for Java, Groovy, OSGi, Web and Scala projects. Even more, this declarative language is extensible. Add your own new language elements or enhance the existing ones, thus providing concise, maintainable and comprehensible builds.
                        </p>
                    </dd>
                    <dt><span class="term">基于依赖的编程语言<br> Language for dependency based programming</span></dt>
                    <dd>
                    	<p>声明式的语言描述在通用任务图中具有更高优先级，可以用来更加灵活地支持你的构建，可以最大程度的满足构建中的特殊需求。</p>
                        <p>The declarative language lies on top of a general purpose task graph, which you can fully leverage in your builds. It provides utmost flexibility to adapt Gradle to your unique needs.
                        </p>
                    </dd>
                    <dt><span class="term">结构化构建<br>Structure your build</span></dt>
                    <dd>
                    	<p>Gradle强大的灵活性和通用性可以使你直接为你构建应用一些通用的原则。例如，你可以很容易的应用一些组件来完成你的构建。</p>
                        <p>The suppleness and richness of Gradle finally allows you to apply common design principles to your build. For example, it is very easy to compose your build from reusable pieces of build logic. Inline stuff where unnecessary indirections would be inappropriate. Don't be forced to tear apart what belongs together (e.g. in your project hierarchy). Avoid smells like shotgun changes or divergent change that turn your build into a maintenance nightmare. At last you can create a well structured, easily maintained, comprehensible build.</p>
                    </dd>
                    <dt><span class="term">可深化的API<br>Deep API</span></dt>
                    <dd>
                    	<p>你会非常乐意在整个构建执行的生命周期中使用 Gradle, 因为Gradle允许你管理和定制它的配置和执行行为。</p>
                        <p>From being a pleasure to be used embedded to its many hooks over the whole lifecycle of build execution, Gradle allows you to monitor and customize its configuration and execution behavior to its very core.
                        </p>
                    </dd>
                    <dt><span class="term">良好的伸缩性 - Gradle scales</span></dt>
                    <dd>
                    	<p>
                    		Gradle拥有良好的伸缩性，从简单的单一项目构建到企业级的多项目构建，这能显著提高您得生产效率。对于结构化构建而言这是实实在在的特性。藉由最先进的增量构建方法，可以切实解决大型企业级项目构建时的性能之痛。

                    	</p>
                        <p>Gradle scales very well. It significantly increases your productivity, from simple single project builds up to huge enterprise multi-project builds. This is true for structuring the build. With the state-of-art incremental build function, this is also true for tackling the performance pain many large enterprise builds suffer from.
                        </p>
                    </dd>
                    <dt><span class="term">支持多项目构建<br>Multi-project builds</span></dt>
                    <dd>
                    	<p>
                    		Gradle对多项目构建的支持十分优秀。项目的依赖是一等公民，您可以在多项目构建中自行组织项目之间的关系，Gralde将遵循您的配置。
                    		<br>
                    		同时，Gradle提供了局部构建的功能.如果你构建一个单独的子项目, Gradle 会构建这个子项目依赖的所有子项目。 你也可以选择依赖于另一个特别的子项目重新构建这些子项目。 这样在一些大型项目里就可以节省非常多的时间。

                    	</p>
                        <p>Gradle's support for multi-project build is outstanding. Project dependencies are first class citizens. We allow you to model the project relationships in a multi-project build as they really are for your problem domain. Gradle follows your layout not vice versa.
                        </p>
                        <p>Gradle provides partial builds. If you build a single subproject Gradle takes care of building all the subprojects that subproject depends on. You can also choose to rebuild the subprojects that depend on a particular subproject. Together with incremental builds this is a big time saver for larger builds.
                        </p>
                    </dd>
                    <dt><span class="term">可采用多种方式进行依赖管理<br>Many ways to manage your dependencies</span></dt>
                    <dd>
                    	<p>
                    		每个团队都有管理外部依赖的方式。从远程Maven仓库或者Ivy仓库的依赖管理到本地文件系统中的依赖，Gradle针对各种方式提供了便利的支持。

                    	</p>
                        <p>Different teams prefer different ways to manage their external dependencies. Gradle provides convenient support for any strategy. From transitive dependency management with remote Maven and Ivy repositories to jars or directories on the local file system.</p>
                    </dd>
                    <dt><span class="term">第一个一站式构建工具<br>Gradle is the first build integration tool</span></dt>
                    <dd>
                    	<p>
                    		Ant 中的task是 Ant 中的核心构成。而更有趣的是，Ant projects 也同样是核心构成。 Gradle 对任意的 Ant 项目提供了深度导入，并在运行时将 Ant 目标(target)转换为原生的 Gradle 任务(task)。 你可以从 Gradle 上依赖它们(Ant targets)，增强它们，甚至在你的 build.xml 上定义对 Gradle tasks 的依赖。Gradle 为属性、路径等等提供了同样的整合。

Gradle 完全支持用于发布或检索依赖的 Maven 或 Ivy 仓库。 Gradle 同样提供了一个转换器，用于将一个 Maven pom.xml 文件转换为一个 Gradle 脚本。Maven 项目的运行时导入的功能将很快会有。
                    	</p>
                        <p>Ant tasks are first class citizens. Even more interesting, Ant projects are first class citizens as well. Gradle provides a deep import for any Ant project, turning Ant targets into native Gradle tasks at runtime. You can depend on them from Gradle, you can enhance them from Gradle, you can even declare dependencies on Gradle tasks in your build.xml. The same integration is provided for properties, paths, etc ...</p>
                        <p>Gradle fully supports your existing Maven or Ivy repository infrastructure for publishing and retrieving dependencies. Gradle also provides a converter for turning a Maven <code class="filename">pom.xml</code> into a Gradle script. Runtime imports of Maven projects will come soon.</p>
                    </dd>
                    <dt><span class="term">易于集成<br>Ease of migration</span></dt>
                    <dd>
                    	<p>
                    		Gradle可以适应任何你有的结构。 因此，您可以随时在同一个分支中开发您的Gradle构建，您的生产构建存在，并且可以并行演化。 我们通常建议编写测试，确保生成的工件是相似的。 这样迁移的破坏性越小，越可靠越好。 这是遵循通过应用婴儿步骤重构的最佳实践。
                    	</p>
                        <p>Gradle can adapt to any structure you have. Therefore you can always develop your Gradle build in the same branch where your production build lives and both can evolve in parallel. We usually recommend to write tests that make sure that the produced artifacts are similar. That way migration is as less disruptive and as reliable as possible. This is following the best-practices for refactoring by applying baby steps.
                        </p>
                    </dd>
                    <dt><span class="term">Groovy</span></dt>
                    <dd>
                    	<p>
                    	Gradle 的构建脚本是采用 Groovy 写的，而不是用 XML。 但与其他方法不同，它并不只是展示了由一种动态语言编写的原始脚本的强大。 那样将导致维护构建变得很困难。 Gradle 的整体设计是面向被作为一门语言，而不是一个僵化的框架。 并且 Groovy 是我们允许你通过抽象的 Gradle 描述你个人的 story 的黏合剂。 Gradle 提供了一些标准通用的 story。这是我们相比其他声明性构建系统的主要特点。 我们的 Groovy 支持也不是简单的糖衣层，整个 Gradle 的 API 都是完全 groovy 化的。只有通过 Groovy才能去运用它并对它提高效率。
                    	</p>
                        <p>Gradle's build scripts are written in Groovy, not XML. But unlike other approaches this is not for simply exposing the raw scripting power of a dynamic language. That would just lead to a very difficult to maintain build. The whole design of Gradle is oriented towards being used as a language, not as a rigid framework. And Groovy is our glue that allows you to tell your individual story with the abstractions Gradle (or you) provide. Gradle provides some standard stories but they are not privileged in any form. This is for us a major distinguishing feature compared to other declarative build systems. Our Groovy support is not just sugar coating. The whole Gradle API is fully Groovy-ized. Adding Groovy results in an enjoyable and productive experience.
                        </p>
                    </dd>
                    <dt><span class="term">The Gradle wrapper</span></dt>
                    <dd>
                    	<p>Gradle Wrapper可以使你在没有安装Gradle的机器上执行构建。这对一些持续集成服务器来说是非常有用的。对于开源项目而言，这也会降低采用Gradle进行构建的入门门槛。对企业而言，采用Gradle Wrapper无需为客户机提供相应的管理方法。采用它可以轻易地采用统一Gradle版本进行构建。
                    	
                    	</p>
                        <p>The Gradle Wrapper allows you to execute Gradle builds on machines where Gradle is not installed. This is useful for example for some continuous integration servers. It is also useful for an open source project to keep the barrier low for building it. The wrapper is also very interesting for the enterprise. It is a zero administration approach for the client machines. It also enforces the usage of a particular Gradle version thus minimizing support issues.
                        </p>

                    	<blockquote>译者注：有人把Wrapper称作包装器，有人称之为封装。简而言之，言而简之 ：Gradle Wrapper 就是一个打包好了的Gradle，不需要你进行额外的配置，它会自己去下载Gradle安装包，调用原始的Gradle命令。</blockquote>	
                    </dd>
                    <dt><span class="term">免费且开源<br>Free and open source</span></dt>
                    <dd>
                     <p>Gradle 是开源项目, 遵循 <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a>许可。
                     </p>
                        <p>Gradle is an open source project, and is licensed under the <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a>.
                        </p>
                    </dd>
                </dl>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:why_groovy" class="section-anchor" href="#sec:why_groovy"></a>2.2.为何选用 Groovy - Why Groovy?</h2></div>
                </div>
            </div>
            <p>
            	我们认为采用基于动态语言的DSL作为脚本语言相对XML具有更大的优势。为何我们在众多动态语言中选中了Groovy呢？原因在于Gradle上下文的操作性。虽然Gradle核心是一个通用的构建工具，但它更主要的还是聚焦于JAVA项目的构建。在Java项目中团队成员对Java都非常熟悉，所以我们尽可能的保证构建过程对所有的团队成员都是透明的。

            </p>
            <p>We think the advantages of an internal DSL (based on a dynamic language) over XML are tremendous when used in <span class="emphasis"><em>build scripts</em></span>. There are a couple of dynamic languages out there. Why Groovy? The answer lies in the context Gradle is operating in. Although Gradle is a general purpose build tool at its core, its main focus are Java projects. In such projects the team members will be very familiar with Java. We think a build should be as transparent as possible to <span class="emphasis"><em>all</em></span> team members.
            </p>
            <p>
            	或许你可能会疑问为何不直接用 Java 作为构建脚本语言，这里有一个问题，就是对于团队的最高的透明度和最低的学习曲线，但是由于 Java 的一些限制，作为构建脚本并不理想。相较而言，Python、Groovy、Rudy都更能胜任此项工作。我们选择 Groovy 是因为它较其他语言而言对 Java 开发者更加透明。它的基本语法与 Java 类似，包括 本文系统，包结构和其他方面。Groovy 提供了最重要内容但都是符合 Java 基础功能的。

            </p>
            <p>In that case, you might argue why we don't just use Java as the language for build scripts. We think this is a valid question. It would have the highest transparency for your team and the lowest learning curve, but because of the limitations of Java, such a build language would not be as nice, expressive and powerful as it could be.
                <sup>[<a href="#ftn.N100C6" name="N100C6" class="footnote">1</a>]</sup> Languages like Python, Groovy or Ruby do a much better job here. We have chosen Groovy as it offers by far the greatest transparency for Java people. Its base syntax is the same as Java's as well as its type system, its package structure and other things. Groovy provides much more on top of that, but with the common foundation of Java.
            </p>
           	<p>
           		对于对 Python 或 Ruby 知识拥有强烈的学习欲望的 Java 开发者来说，上述论点不适用。该工具的设计非常适合于创建另一个建立在 JRuby 和Jython 脚本引擎。对于我们来说暂时它只是不具有最高优先级。我们高兴地支持任何社区的努力来创建额外的构建脚本引擎。
           	</p>
            <p>For Java developers with Python or Ruby knowledge or the desire to learn them, the above arguments don't apply. The Gradle design is well-suited for creating another build script engine in JRuby or Jython. It just doesn't have the highest priority for us at the moment. We happily support any community effort to create additional build script engines.
            </p>
        </div>
        <div class="footnotes">
            <br>
            <hr align="left" width="100">
            <div class="footnote">
                <p><sup>[<a href="#N100C6" name="ftn.N100C6" class="para">1</a>] </sup>At
                    <a class="ulink" href="http://www.defmacro.org/ramblings/lisp.html" target="_top">http://www.defmacro.org/ramblings/lisp.html</a> you find an interesting article comparing Ant, XML, Java and Lisp. It's funny that the 'if Java had that syntax' syntax in this article is actually the Groovy syntax.
                </p>
            </div>
        </div>
    </div>
    <div class="navfooter">
        <div>
            <div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="../ch1/introduction.html" title="Introduction - Gradle User Guide Version 3.2">上一页</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../userguide.html" title="Gradle User Guide Version 3.2">目录</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">下一页</a></div>
        </div>
    </div>
</body>

</html>
