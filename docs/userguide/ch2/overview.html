<html>

<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Overview - Gradle User Guide Version 3.2</title>
    <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="../base.css">
    <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="../docs.css">
    <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="../userguide.css">
    <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
    <link rel="home" href="../userguide.html" title="Gradle User Guide Version 3.2">
    <link rel="up" href="../pt01.html" title="Part&nbsp;I.&nbsp;About Gradle">
    <link rel="prev" href="../introduction.html" title="Introduction - Gradle User Guide Version 3.2">
    <link rel="下一页" href="../pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">
</head>

<body>
    <div class="navheader">
        <div>
            <div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="../introduction.html" title="Introduction - Gradle User Guide Version 3.2">上一页</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../userguide.html" title="Gradle User Guide Version 3.2">目录</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">下一页</a></div>
        </div>
    </div>
    <div class="chapter">
        <div class="titlepage">
            <div>
                <div>
                    <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="overview"></a>Chapter&nbsp;2.&nbsp;Overview</h1></div>
            </div>
        </div>
        <div class="toc">
            <p><b>章节目录 - Table of Content</b></p>
            <dl>
                <dt><span class="section"><a href="overview.html#sec:special_feature_of_gradle">2.1. 特性 - Features</a></span></dt>
                <dt><span class="section"><a href="overview.html#sec:why_groovy">2.2. 为何采用 Groovy - Why Groovy?</a></span></dt>
            </dl>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:special_feature_of_gradle" class="section-anchor" href="#sec:special_feature_of_gradle"></a>2.1. 特性 - Features</h2></div>
                </div>
            </div>
            <p>下面罗列了一些Gradle的特性。</p>
            <p>Here is a list of some of Gradle's features.
            </p>
            <div class="variablelist">
                <dl>
                    <dt><span class="term">声明式构建和契约式构建<br>Declarative builds and build-by-convention</span></dt>
                    <dd>
                    	<p>Gradle的核心是基于Groovy的DSL(领域特定语言)。Gradle通过提供声明式的语言元素来将声明式构建提高到一个新的水平，您可以根据自己的喜好组装。 这些元素还为Java，Groovy，OSGi，Web和Scala项目提供按惯例支持。 甚至，这种声明式的语言是可扩展的。 添加您自己的新语言元素或增强现有语言元素，从而提供简洁，可维护和易理解的构建。</p>
                        <p>At the heart of Gradle lies a rich extensible Domain Specific Language (DSL) based on Groovy. Gradle pushes declarative builds to the next level by providing declarative language elements that you can assemble as you like. Those elements also provide build-by-convention support for Java, Groovy, OSGi, Web and Scala projects. Even more, this declarative language is extensible. Add your own new language elements or enhance the existing ones, thus providing concise, maintainable and comprehensible builds.
                        </p>
                    </dd>
                    <dt><span class="term">基于依赖的编程语言<br> Language for dependency based programming</span></dt>
                    <dd>
                    	<p>声明式的语言描述在通用任务图中具有更高优先级，可以用来更加灵活地支持你的构建，可以最大程度的满足构建中的特殊需求。</p>
                        <p>The declarative language lies on top of a general purpose task graph, which you can fully leverage in your builds. It provides utmost flexibility to adapt Gradle to your unique needs.
                        </p>
                    </dd>
                    <dt><span class="term">结构化构建<br>Structure your build</span></dt>
                    <dd>
                    	<p></p>
                        <p>The suppleness and richness of Gradle finally allows you to apply common design principles to your build. For example, it is very easy to compose your build from reusable pieces of build logic. Inline stuff where unnecessary indirections would be inappropriate. Don't be forced to tear apart what belongs together (e.g. in your project hierarchy). Avoid smells like shotgun changes or divergent change that turn your build into a maintenance nightmare. At last you can create a well structured, easily maintained, comprehensible build.</p>
                    </dd>
                    <dt><span class="term">可深化API<br>Deep API</span></dt>
                    <dd>
                        <p>From being a pleasure to be used embedded to its many hooks over the whole lifecycle of build execution, Gradle allows you to monitor and customize its configuration and execution behavior to its very core.
                        </p>
                    </dd>
                    <dt><span class="term">Gradle scales</span></dt>
                    <dd>
                        <p>Gradle scales very well. It significantly increases your productivity, from simple single project builds up to huge enterprise multi-project builds. This is true for structuring the build. With the state-of-art incremental build function, this is also true for tackling the performance pain many large enterprise builds suffer from.
                        </p>
                    </dd>
                    <dt><span class="term">支持多项目构建<br>Multi-project builds</span></dt>
                    <dd>
                        <p>Gradle's support for multi-project build is outstanding. Project dependencies are first class citizens. We allow you to model the project relationships in a multi-project build as they really are for your problem domain. Gradle follows your layout not vice versa.
                        </p>
                        <p>Gradle provides partial builds. If you build a single subproject Gradle takes care of building all the subprojects that subproject depends on. You can also choose to rebuild the subprojects that depend on a particular subproject. Together with incremental builds this is a big time saver for larger builds.
                        </p>
                    </dd>
                    <dt><span class="term">可采用多种方式进行依赖管理<br>Many ways to manage your dependencies</span></dt>
                    <dd>
                    	<p>
                    		每个团队都有管理外部依赖的方式。从远程Maven仓库或者Ivy仓库的依赖管理到本地文件系统中的依赖，Gradle针对各种方式提供了便利的支持。

                    	</p>
                        <p>Different teams prefer different ways to manage their external dependencies. Gradle provides convenient support for any strategy. From transitive dependency management with remote Maven and Ivy repositories to jars or directories on the local file system.</p>
                    </dd>
                    <dt><span class="term">第一个集成式构建工具<br>Gradle is the first build integration tool</span></dt>
                    <dd>
                        <p>Ant tasks are first class citizens. Even more interesting, Ant projects are first class citizens as well. Gradle provides a deep import for any Ant project, turning Ant targets into native Gradle tasks at runtime. You can depend on them from Gradle, you can enhance them from Gradle, you can even declare dependencies on Gradle tasks in your build.xml. The same integration is provided for properties, paths, etc ...</p>
                        <p>Gradle fully supports your existing Maven or Ivy repository infrastructure for publishing and retrieving dependencies. Gradle also provides a converter for turning a Maven <code class="filename">pom.xml</code> into a Gradle script. Runtime imports of Maven projects will come soon.</p>
                    </dd>
                    <dt><span class="term">易于集成<br>Ease of migration</span></dt>
                    <dd>
                    	<p>
                    		Gradle可以适应任何你采用的结构。
                    	</p>
                        <p>Gradle can adapt to any structure you have. Therefore you can always develop your Gradle build in the same branch where your production build lives and both can evolve in parallel. We usually recommend to write tests that make sure that the produced artifacts are similar. That way migration is as less disruptive and as reliable as possible. This is following the best-practices for refactoring by applying baby steps.
                        </p>
                    </dd>
                    <dt><span class="term">Groovy</span></dt>
                    <dd>
                        <p>Gradle's build scripts are written in Groovy, not XML. But unlike other approaches this is not for simply exposing the raw scripting power of a dynamic language. That would just lead to a very difficult to maintain build. The whole design of Gradle is oriented towards being used as a language, not as a rigid framework. And Groovy is our glue that allows you to tell your individual story with the abstractions Gradle (or you) provide. Gradle provides some standard stories but they are not privileged in any form. This is for us a major distinguishing feature compared to other declarative build systems. Our Groovy support is not just sugar coating. The whole Gradle API is fully Groovy-ized. Adding Groovy results in an enjoyable and productive experience.
                        </p>
                    </dd>
                    <dt><span class="term">The Gradle wrapper</span></dt>
                    <dd>
                    	<p>Gradle Wrapper可以使你在没有安装Gradle的机器上执行构建。这对一些持续集成服务器来说是非常有用的。对于开源项目而言，这也会降低采用Gradle进行构建的入门门槛。对企业而言，采用Gradle Wrapper无需为客户机提供相应的管理方法。采用它可以轻易地采用统一Gradle版本进行构建。
                    	
                    	</p>
                        <p>The Gradle Wrapper allows you to execute Gradle builds on machines where Gradle is not installed. This is useful for example for some continuous integration servers. It is also useful for an open source project to keep the barrier low for building it. The wrapper is also very interesting for the enterprise. It is a zero administration approach for the client machines. It also enforces the usage of a particular Gradle version thus minimizing support issues.
                        </p>

                    	<blockquote>译者注：有人把Wrapper称作包装器，有人称之为封装。简而言之，言而简之 ：Gradle Wrapper 就是一个打包好了的Gradle，不需要你进行额外的配置，它会自己去下载Gradle安装包，调用原始的Gradle命令。</blockquote>	
                    </dd>
                    <dt><span class="term">免费且开源<br>Free and open source</span></dt>
                    <dd>
                     <p>Gradle 是开源项目, 遵循 <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a>许可。
                     </p>
                        <p>Gradle is an open source project, and is licensed under the <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a>.
                        </p>
                    </dd>
                </dl>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:why_groovy" class="section-anchor" href="#sec:why_groovy"></a>2.2.为何采用 Groovy - Why Groovy?</h2></div>
                </div>
            </div>
            <p>We think the advantages of an internal DSL (based on a dynamic language) over XML are tremendous when used in <span class="emphasis"><em>build scripts</em></span>. There are a couple of dynamic languages out there. Why Groovy? The answer lies in the context Gradle is operating in. Although Gradle is a general purpose build tool at its core, its main focus are Java projects. In such projects the team members will be very familiar with Java. We think a build should be as transparent as possible to <span class="emphasis"><em>all</em></span> team members.
            </p>
            <p>In that case, you might argue why we don't just use Java as the language for build scripts. We think this is a valid question. It would have the highest transparency for your team and the lowest learning curve, but because of the limitations of Java, such a build language would not be as nice, expressive and powerful as it could be.
                <sup>[<a href="#ftn.N100C6" name="N100C6" class="footnote">1</a>]</sup> Languages like Python, Groovy or Ruby do a much better job here. We have chosen Groovy as it offers by far the greatest transparency for Java people. Its base syntax is the same as Java's as well as its type system, its package structure and other things. Groovy provides much more on top of that, but with the common foundation of Java.
            </p>
            <p>For Java developers with Python or Ruby knowledge or the desire to learn them, the above arguments don't apply. The Gradle design is well-suited for creating another build script engine in JRuby or Jython. It just doesn't have the highest priority for us at the moment. We happily support any community effort to create additional build script engines.
            </p>
        </div>
        <div class="footnotes">
            <br>
            <hr align="left" width="100">
            <div class="footnote">
                <p><sup>[<a href="#N100C6" name="ftn.N100C6" class="para">1</a>] </sup>At
                    <a class="ulink" href="http://www.defmacro.org/ramblings/lisp.html" target="_top">http://www.defmacro.org/ramblings/lisp.html</a> you find an interesting article comparing Ant, XML, Java and Lisp. It's funny that the 'if Java had that syntax' syntax in this article is actually the Groovy syntax.
                </p>
            </div>
        </div>
    </div>
    <div class="navfooter">
        <div>
            <div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="../ch1/introduction.html" title="Introduction - Gradle User Guide Version 3.2">上一页</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../userguide.html" title="Gradle User Guide Version 3.2">目录</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="../pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">下一页</a></div>
        </div>
    </div>
</body>

</html>
